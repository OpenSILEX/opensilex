package org.opensilex.utils.security;

import org.opensilex.utils.functionnal.ThrowingSupplier;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.Charset;
import java.util.Arrays;

/**
 * Utility class used for read sensitive information (secrets, keys, password) from InputStream
 *
 * @author rcolin
 */
public class SecretReadUtils {

    public static final char WIPE_CHAR = '\0';

    private SecretReadUtils() {
    }

    /**
     * Read a secret from any InputStream by trying to limit the exposure of secret in memory during read process.
     *
     * @param inputStreamFunction a Function which generate an {@link InputStream}.
     *                            This method ensures that the generated stream is always closed with {@link InputStream#close()}, in case of I/O errors.
     * @return A secret read from an {@link InputStream}
     * @throws IOException if some I/O error occurs during stream read
     * @apiNote <ul>
     * <li>This method use char array instead of {@link String} for dealing with sensitive data. </li>
     * <li>Temporary buffer and arrays created during read, are immediately cleared after use.</li>
     * <li>This method use directly allocated NIO which don't use intermediate/extra HEAP memory allocation. {@link ByteBuffer#allocateDirect(int)}</li>
     * <li>This method only try to limit the exposure of secret during stream read.
     * If the implementation generated by the inputStreamFunction rely on extra memory allocation (like a buffer), then temporary/intermediate secret can still be exposed in memory.</li>
     * </ul>
     * @see <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#ReadPassword">Password handling in JAVA</a>
     * @see <a href="https://wiki.sei.cmu.edu/confluence/display/java/MSC59-J.+Limit+the+lifetime+of+sensitive+data">Java sensitive data lifetime</a>
     */
    public static char[] readSecret(ThrowingSupplier<InputStream, IOException> inputStreamFunction, Charset encoding) throws IOException {

        char[] secret = new char[0];

        // Get stream and readable Channel. Ensure that they are always closed within try block
        try (InputStream inputStream = inputStreamFunction.get();
             ReadableByteChannel inputChannel = Channels.newChannel(inputStream)) {

            // Use a directly allocated NIO (new I/O) ByteBuffer. This buffer has no backing array.
            // No buffer is maintained during channel stream read by the ByteBuffer since it has no backing array.
            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024);
            while ((inputChannel.read(byteBuffer)) > 0) {

                // Flip buffer after previous read -> reset position/limit index at the beginning
                // Extends the array with a higher capacity (with a copy) and wipe old secret
                byteBuffer.flip();
                CharBuffer charBuffer = encoding.decode(byteBuffer);
                char[] reallocatedCopy = Arrays.copyOf(secret, secret.length + charBuffer.limit());
                wipe(secret);

                // read buffer inside new secret and wipe buffers
                charBuffer.get(reallocatedCopy, secret.length, charBuffer.limit());
                wipe(charBuffer);
                wipe(byteBuffer);
                secret = reallocatedCopy;
            }
            return secret;

        } catch (IOException e) {  // ensure that temporary buffer/array are always cleaned and wiped in case or error
            wipe(secret);
            throw e;
        }
    }

    public static void wipe(char[] secret) {
        Arrays.fill(secret, WIPE_CHAR);
    }

    public static void wipe(byte[] secret) {
        Arrays.fill(secret, (byte) 0);
    }

    public static void wipe(CharBuffer buffer) {
        buffer.clear();
        for (int i = buffer.position(); i < buffer.limit(); i++) {
            buffer.put(WIPE_CHAR);
        }
        buffer.clear();
    }

    public static void wipe(ByteBuffer buffer) {
        buffer.clear();
        for (int i = buffer.position(); i < buffer.limit(); i++) {
            buffer.put((byte) 0);
        }
        buffer.clear();
    }

    public static byte[] getBytes(char[] srcChars, Charset encoding) {

        CharBuffer charBuffer = CharBuffer.wrap(srcChars);
        ByteBuffer byteBuffer = encoding.encode(charBuffer);
        byte[] bytes = Arrays.copyOfRange(byteBuffer.array(), byteBuffer.position(), byteBuffer.limit());

        wipe(charBuffer.array());
        wipe(byteBuffer.array());

        return bytes;
    }

}
